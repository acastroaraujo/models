{
  "hash": "ea33f0d6098e5bac84b4562d3a4e65ce",
  "result": {
    "markdown": "---\ntitle: \"Network Models\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n*Note. The* [**`igraph`**](https://r.igraph.org/reference/index.html) *package is used for the examples below.*\n\n## Introduction\n\n> Any model we construct, be it of a market, the spread of a disease, or the transmission of information, can be enriched by embedding the actors in a network.\n>\n> @page2018 [pp. 117]\n\nA **network** is a representation of a system that contains discrete, interconnected elements. The elements are represented by **nodes** (or *vertices),* and the interconnections are represented by **edges** (or *ties).*\n\nEdges may have *attributes* like distance or monetary transactions---i.e., weights. They may also be *directed* or *undirected*, depending on whether the relationships they represent are asymmetric or symmetric.\n\nMany real-world problems can be solved using **graph algorithms**. For example, *Dijkstra's shortest path algorithm* is an efficient way to find the shortest path from a node to all other nodes in a graph.\n\n**Formal Presentation**\n\nA graph is a mathematical object that consists of a set of $V$ of vertices (or nodes) and a multiset $E$ of pairs of elements in $V$. It encodes *relational information* (or connections).\n\n<aside>A *weighted* graph will contain another set of elements associated to each pair of nodes in $E$.</aside>\n\n$$\nG = \\{V, E\\}\n$$\n\n<aside>A multiset is an set in which elements are allowed to appear more than once. For example: $\\{a, a, b, c, c, c\\}$.</aside>\n\nWhen two nodes $a$ and $b$ are connected, $\\{a, b\\} \\in E$, we call them *adjacent.*\n\nWe can also represent a graph as an **adjacency matrix** $\\mathbf{M}$ such that each entry $m_{ij}$ is zero when $\\{i, j\\} \\not \\in E$.\n\n$$\nm_{ij} = \\begin{cases} \n1 &\\text{if } (v_i, v_j) \\in E \\\\\n0 &\\text{if } (v_i, v_j) \\not \\in E \n\\end{cases}\n$$\n\n\n::: {.cell layout=\"[2, 3]\" layout-align=\"center\"}\n\n```{.r .cell-code}\n# Adj. Matrix\nset.seed(1111)\nn <- 5\nM <- array(\n  data = sample(1:0, size = n*n, replace = TRUE), \n  dim = c(n, n),\n  dimnames = list(letters[1:n], letters[1:n])\n)\n\ndiag(M) <- 0\n\nknitr::kable(M) |> \n  kableExtra::kable_styling()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:right;\"> a </th>\n   <th style=\"text-align:right;\"> b </th>\n   <th style=\"text-align:right;\"> c </th>\n   <th style=\"text-align:right;\"> d </th>\n   <th style=\"text-align:right;\"> e </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> a </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> b </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> c </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> d </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> e </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n```{.r .cell-code}\n# Graph\n\nlibrary(igraph)\nlibrary(ggraph)\n\nnet <- igraph::graph_from_adjacency_matrix(M, mode = \"directed\") \n\nnet |> \n  ggraph() + \n  geom_node_text(aes(label = name), color = \"steelblue1\", size = 8) + \n  geom_edge_fan(\n    arrow = arrow(length = unit(0.25, \"cm\")),\n    end_cap = circle(.5, \"cm\"),\n    start_cap = circle(.5, \"cm\"),\n    colour = \"steelblue1\"\n  ) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](net-00-intro_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nThe matrix representation is better suited for calculating all sorts of network statistics. In what follows, we will refer to these objects as `M` and `net` respectively.\n\n## Network Statistics\n\n### Nodes\n\n**Degree**\n\nThis measure captures the number of ties for each node. When we look at *directed* graphs, we need to distinguish between two types of degrees:\n\n-   **outdegree:** the number of ties *sent* from node $i$\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    rowSums(M)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    a b c d e \n    4 1 1 2 2 \n    ```\n    :::\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    igraph::degree(net, mode = \"out\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    a b c d e \n    4 1 1 2 2 \n    ```\n    :::\n    :::\n\n\n-   **indegree:** the number of ties *received* by node $i$\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    colSums(M)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    a b c d e \n    0 2 3 1 4 \n    ```\n    :::\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    igraph::degree(net, mode = \"in\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    a b c d e \n    0 2 3 1 4 \n    ```\n    :::\n    :::\n\n\nThe *degree distribution* tells us if some nodes are more connected than others. Social networks usually have more equal distributions than networks connecting websites or citations among documents, all of which have long tails.\n\n<aside>A **power-law network** is a network whose degree distribution follows a \"power law.\"</aside>\n\n**Neighbors**\n\nThe set of nodes in $u$'s neighborhood is usually depicted as $N_u$ and $|N_u|$ represents the number of nodes in that neighborhood.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nigraph::neighbors(net, v = \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 4/5 vertices, named, from 4ef57b9:\n[1] b c d e\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nigraph::neighborhood(net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 5/5 vertices, named, from 4ef57b9:\n[1] a b c d e\n\n[[2]]\n+ 3/5 vertices, named, from 4ef57b9:\n[1] b a e\n\n[[3]]\n+ 4/5 vertices, named, from 4ef57b9:\n[1] c a d e\n\n[[4]]\n+ 4/5 vertices, named, from 4ef57b9:\n[1] d a c e\n\n[[5]]\n+ 5/5 vertices, named, from 4ef57b9:\n[1] e a b c d\n```\n:::\n:::\n\n\n*Note that the `igraph::neighborhood()` function includes* $u$ *among* $N_u$*.*\n\n**Local Clustering Coefficient**\n\nThe clustering coefficient of $u$ is the percentage of $u$'s pairs of neighbors that are also connected by a tie---e.g., if $u$ has a neighborhood of size 10, then it has ${10 \\choose 2} = 45$ pairs of friends; if 15 of those 45 pairs are themselves connected, then $u$'s clustering coefficient equal $\\frac{1}{3}$.\n\nI don't know about the following equations...\n\n-   Frequency Interpretation:\n\n    $$\n    C_u = \\frac{| \\{{v, w \\in N_u \\mid (v, w) \\in E} \\}|}{|N_u| \\times (|N_u| - 1)}\n    $$\n\n-   Probability Interpretation:\n\n**Betweenness**\n\nBetweennnes. The number of paths of minimal length connecting two other nodes that pass through one node.\n\nThe average length between nodes gets shorter as we add more edges to a graph.\n\n### Network\n\n**Density**\n\nThis measure captures the total number of edges (or ties) in the network, divided by the total number of possible edges.\n\nGetting to the total number of possible edges requires a little bit of combinatorics:\n\n-   Possible edges in an undirected network\n\n    $$\n    {n \\choose 2} = \\frac{n!}{(n - 2)! 2!} = \\frac{n (n-1)}{2}\n    $$\n\n-   Possible edges in a directed network\n\n    $$\n    \\underbrace{P(n, 2)}_\\text{permutation} = \\frac{n!}{(n-2)!} = n(n-1)\n    $$\n\n-   Possible edges in an undirected network (loops allowed)\n\n    $$\n    {n \\choose 2} + \\underbrace{n}_\\text{diagonal} = \\frac{n (n-1)}{2} + n\n    $$\n\n-   Possible edges in a directed network (loops allowed)\n\n    $$\n    P(n, 2) + \\underbrace{n}_\\text{diagonal} = n(n-1) + n\n    $$\n\nThus, the **density** of a graph $G = \\{V, E\\}$ is simply:\n\n$$\n\\text{density}(G_n) = \\frac{|E|}{|V| \\cdot (|V| - 1)}\n$$\n\nHere is how we perform such a calculation:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nn_nodes <- igraph::gorder(net)\nn_edges <- igraph::gsize(net)\nn_possible_edges <- n_nodes * (n_nodes - 1)\n## density\nn_edges / n_possible_edges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nigraph::edge_density(net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\n### Flow\n\n**Walks**\n\nAny sequence of edges that connect $i$ to $j$. For example, the following sequence is a walk of length 4 from $i$ to $j$:\n\n$$\ni \\to k \\to l \\to k \\to j\n$$\n\nBy raising the adjacency matrix to the n^th^ power, we get the number of walks of length $n$ between all $i,j$ pairs.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nwalks <- function(M, n) {\n  stopifnot(n >= 0, nrow(M) == ncol(M))\n  if (n == 0) {\n   diag(nrow(M))\n  } else{\n   Reduce(`%*%`, rep(list(M), n)) \n  }\n}\n\n## number of walks of length 3\nwalks(M, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b c d e\na 0 3 3 0 3\nb 0 0 0 0 2\nc 0 0 0 0 2\nd 0 1 1 0 2\ne 0 2 2 0 0\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nM %*% M %*% M \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b c d e\na 0 3 3 0 3\nb 0 0 0 0 2\nc 0 0 0 0 2\nd 0 1 1 0 2\ne 0 2 2 0 0\n```\n:::\n:::\n\n\n**Paths**\n\nPath length. The minimum number of edges that must be traversed to get from one node to another.\n\nAny sequence of edges that connect $i$ to $j$, where a path is *not* allowed to revisit the same node twice (unlike walks). We use the `igraph::distances()` function to get the shortest path (or distance) between every node. The `mode = \"out\"` argument says we want the distance from $i$ to $j$, which is what we typically want.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndist_mat <- igraph::distances(net, mode = \"out\")\ndist_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    a b c   d e\na   0 1 1   1 1\nb Inf 0 2 Inf 1\nc Inf 2 0 Inf 1\nd Inf 2 1   0 1\ne Inf 1 1 Inf 0\n```\n:::\n:::\n\n\nHere, we can see there is *at least* one path of length 2 between $c$ and $b$. Note that `Inf` means that $i$ cannot reach $j$ through any path. To get the specific paths connecting $i$ to $j$ we can use the `all_shortest_paths()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nigraph::all_shortest_paths(net, from = \"d\", to = \"b\", mode = \"out\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n$res[[1]]\n+ 3/5 vertices, named, from 4ef57b9:\n[1] d e b\n\n\n$nrgeo\n[1] 0 1 1 1 1\n```\n:::\n:::\n\n\n<aside>`nrgeo` is the resultant vector of values from **Djikstra's algorithm** which is used to find the shortest paths.</aside>\n\nIt's often the case that we want to summarize the distance over *all* $i,j$ pairs. We can calculate this using the distance matrix calculated above.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndiag(dist_mat) <- NA # remove the elements in the diagonal\nmean(dist_mat[dist_mat != Inf], na.rm = TRUE) # # remove Inf values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.230769\n```\n:::\n:::\n\n\nThus, we see that nodes are (on average) separated by paths of length 1.23 (excluding pairs that cannot reach each other).\n\nNote that we also remove all `Inf` values, which means we excluded all unreachable pairs. This is a common approach but also throws out information on all cases where $i$ cannot reach $j$.\n\n**Closeness**\n\nAlternatively, we can use the \"closeness\" measure if we have unreachable pairs. Closeness is based on the inverse of the distance matrix. By inverting the distance matrix, all `Inf` values are turned into $0$s and thus can be included in the mean calculation. The inverse of the distance matrix has the opposite interpretation as above, showing show how \"close\" node $i$ is to node $j$. The disadvantage of a closeness measure is that the interpretation is not as intuitive as with distance.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nclose_mat <- 1 / dist_mat \nclose_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   a   b   c  d  e\na NA 1.0 1.0  1  1\nb  0  NA 0.5  0  1\nc  0 0.5  NA  0  1\nd  0 0.5 1.0 NA  1\ne  0 1.0 1.0  0 NA\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nmean(close_mat, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.575\n```\n:::\n:::\n\n\nNote that the \"mean closeness\" will ***not*** mirror the \"mean distance\" because we have now included all unreachable pairs.\n\n**Reachability**\n\nThis measure captures whether node $i$ can reach node $j$ through *any* path. This can be calculated directly from the distance matrix. Node $i$ can reach node $j$ if the distance between them is less than `Inf`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nreach_mat <- ifelse(dist_mat == Inf, 0, 1)\nreach_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   a  b  c  d  e\na NA  1  1  1  1\nb  0 NA  1  0  1\nc  0  1 NA  0  1\nd  0  1  1 NA  1\ne  0  1  1  0 NA\n```\n:::\n:::\n\n\n**Diameter**\n\nWe can also use the distance matrix to calculate diameter, showing the *longest geodesic* (or distance) between any two nodes in the network. Diameter thus takes all of the shortest paths between nodes (i.e., distance) and calculates the longest path among that set.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmax(dist_mat[dist_mat != Inf], na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nigraph::diameter(net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nLike all models, networks are just *abstractions.*\n\n@mcfarland2023 suggest we view network models in terms of two theoretical perspectives and two explanatory purposes, as depicted in @tbl-networks. This is not a definitive statement of network research, but rather a heuristic tool.\n\n+-------------------------+--------------------+-------------------------+\n| Perspective             | Networks as Cause  | Networks as Consequence |\n+=========================+====================+=========================+\n| Connectionist           | Diffusion          | Social integration      |\n|                         |                    |                         |\n| :   *Networks as pipes* | Peer influence     | Peer selection          |\n|                         |                    |                         |\n|                         | Social capital     | Segregation             |\n+-------------------------+--------------------+-------------------------+\n| Positional              | Popularity effects | Exchange patterns       |\n|                         |                    |                         |\n| :   *Networks as roles* | Role behavior      | Network stability       |\n|                         |                    |                         |\n|                         | Network constraing | Career paths            |\n+-------------------------+--------------------+-------------------------+\n\n: Networks and Research Agendas {#tbl-networks}\n\nThis distinctions are important. For example, the average path length between nodes in a graph is correlated with *information loss* because \"information that passes through several people is more likely to suffer distortion than information passed between only two people\" [@page2018, pp. 119]. Similarly, high betweenness scores in social networks imply that the individual will hold more information or wield more power. However, none of these interpretations make no sense when we consider networks-as-roles.\n\n*Note. The field of network analysis has a long interdisciplinary history in sociology, anthropology, psychology, and mathematics. Due to advances in computation---and the creation of the Internet---the ability to collect network information has greatly increased and we're starting to see the rise of a much broader (but fragmented) field of network science. Computers scientists (e.g., Kleinberg), physicists (e.g., Barabassi, Newman), and statisticians (e.g., Snijders, Hancock) have become important new players in the field. As a result, the field has begun to lack a clear integration of theories and methods.*\n\nSEE PAGE 44 FOR FOUR THINGS\n\nsimilarities, relations, interactions, flows\n\nMemberships, in which nodes are located in the same regions in physical and social space (e.g., same neighborhoods, same department, or same club). Relations, in which nodes operate within a system of roles (e.g., father of, friend of, or teacher of) and have cognitive or affective orientations toward one another. Interactions, in which concrete interactions occur between nodes (e.g., advice, romance, or bullying). Flows, in which nodes transfer some material or cultural object, goods, information, or influence (e.g., ideas, beliefs, practices).\n",
    "supporting": [
      "net-00-intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}